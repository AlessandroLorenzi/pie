# üçï `github.com/elliotchance/pie`
[![GoDoc](https://godoc.org/github.com/elliotchance/pie?status.svg)](https://godoc.org/github.com/elliotchance/pie)
[![Build Status](https://travis-ci.org/elliotchance/pie.svg?branch=master)](https://travis-ci.org/elliotchance/pie)
[![codecov](https://codecov.io/gh/elliotchance/pie/branch/master/graph/badge.svg)](https://codecov.io/gh/elliotchance/pie)

**Enjoy a slice!** `pie` is a code generator for dealing with slices that
focuses on type safety, performance and immutability.

- [Quick Start](#quick-start)
  * [Install/Update](#install-update)
  * [Built-in Types](#built-in-types)
  * [Custom Types](#custom-types)
  * [Limiting Functions Generated](#limiting-functions-generated)
- [Functions](#functions)
  * [func `All`(fn func(ElementType) bool) bool](#func--all--fn-func-elementtype--bool--bool)
  * [func `Any`(fn func(ElementType) bool) bool](#func--any--fn-func-elementtype--bool--bool)
  * [func Append(elements ...ElementType) SliceType](#func-append-elements-elementtype--slicetype)
  * [func AreSorted() bool](#func-aresorted---bool)
  * [func AreUnique() bool](#func-areunique---bool)
  * [func Average() float64](#func-average---float64)
  * [func Bottom(n int) SliceType](#func-bottom-n-int--slicetype)
  * [func Contains(lookingFor ElementType) bool](#func-contains-lookingfor-elementtype--bool)
  * [func Each(fn func(ElementType)) SliceType](#func-each-fn-func-elementtype---slicetype)
  * [func Extend(slices ...SliceType) SliceType](#func-extend-slices-slicetype--slicetype)
  * [func First() ElementType](#func-first---elementtype)
  * [func FirstOr(defaultValue ElementType) ElementType](#func-firstor-defaultvalue-elementtype--elementtype)
  * [func Join(glue string) string](#func-join-glue-string--string)
  * [func JSONString() string](#func-jsonstring---string)
  * [func Keys() KeySliceType](#func-keys---keyslicetype)
  * [func Last() ElementType](#func-last---elementtype)
  * [func LastOr(defaultValue ElementType) ElementType](#func-lastor-defaultvalue-elementtype--elementtype)
  * [func Len() int](#func-len---int)
  * [func Max() ElementType](#func-max---elementtype)
  * [func Median() ElementType](#func-median---elementtype)
  * [func Min() ElementType](#func-min---elementtype)
  * [func Reverse() SliceType](#func-reverse---slicetype)
- [FAQ](#faq)
  * [What are the requirements?](#what-are-the-requirements-)
  * [What are the goals of `pie`?](#what-are-the-goals-of--pie--)
  * [How do I contribute a function?](#how-do-i-contribute-a-function-)
  * [Why is the emoji a slice of pizza instead of a pie?](#why-is-the-emoji-a-slice-of-pizza-instead-of-a-pie-)

# Quick Start

## Install/Update

```bash
go get -u github.com/elliotchance/pie
```

## Built-in Types

`pie` ships with some slice types ready to go (pun intended). These include:

- `type`[`Strings`](https://godoc.org/github.com/elliotchance/pie/pie#Strings)`[]string`
- `type`[`Float64s`](https://godoc.org/github.com/elliotchance/pie/pie#Float64s)`[]float64`
- `type`[`Ints`](https://godoc.org/github.com/elliotchance/pie/pie#Ints)`[]int`

These can be used without needing `go generate`. For example:

```go
package main

import (
    "fmt"
    "strings"
    
    "github.com/elliotchance/pie/pie"
)

func main() {
    name := pie.Strings{"Bob", "Sally", "John", "Jane"}.
        Unselect(func (name string) bool {
            return strings.HasPrefix(name, "J")
        }).
        Transform(strings.ToUpper).
        Last()

    fmt.Println(name) // "SALLY"
}
```

## Custom Types

Annotate the slice type in your source code:

```go
type Car struct {
    Name, Color string
}

//go:generate pie Cars.*
type Cars []Car
```

Run `go generate`. This will create a file called `cars_pie.go`. You should
commit this with the rest of your code. Run `go generate` any time you need to
add more types.

Now you can use the slices:

```go
cars := Cars{
    {"Bob", "blue"},
    {"Sally", "green"},
    {"John", "red"},
    {"Jane", "red"},
}

redCars := cars.Select(func(car Car) bool {
    return car.Color == "red"
})

// redCars = Cars{{"John", "red"}, {"Jane", "red"}}
```

Or, more complex operations can be chained:

```go
cars.Unselect(func (car Car) {
        return strings.HasPrefix(car.Name, "J")
    }).
    Transform(func (car Car) Car {
        car.Name = strings.ToUpper(car.Name)
        
        return car
    }).
    Last()

// Car{"SALLY", "green"}
```

## Limiting Functions Generated

The `.*` can be used to generate all functions. This is easy to get going but
creates a lot of unused code. You can limit the functions generated by chaining
the function names with a dot syntax, like:

```go
//go:generate myInts.Average.Sum myStrings.Select
```

This will only generate `myInts.Average`, `myInts.Sum` and `myStrings.Select`.

# Functions

Here is a summary of all of the function. Specific documentation is below.

| Function     | String | Number | Struct| Maps | Big-O    |
| ------------ | :----: | :----: | :----:| :--: | :------: |
| `All`        | ‚úì      | ‚úì      | ‚úì     |      | n        |
| `Any`        | ‚úì      | ‚úì      | ‚úì     |      | n        |
| `Append`     | ‚úì      | ‚úì      | ‚úì     |      | n        |
| `AreSorted`  | ‚úì      | ‚úì      |       |      | n        |
| `AreUnique`  | ‚úì      | ‚úì      |       |      | n        |
| `Average`    |        | ‚úì      |       |      | n        |
| `Bottom`     | ‚úì      | ‚úì      | ‚úì     |      | n        |
| `Contains`   | ‚úì      | ‚úì      | ‚úì     |      | n        |
| `Extend`     | ‚úì      | ‚úì      | ‚úì     |      | n        |
| `Each`       | ‚úì      | ‚úì      | ‚úì     |      | n        |
| `First`      | ‚úì      | ‚úì      | ‚úì     |      | 1        |
| `FirstOr`    | ‚úì      | ‚úì      | ‚úì     |      | 1        |
| `Join`       | ‚úì      |        |       |      | n        |
| `JSONString` | ‚úì      | ‚úì      | ‚úì     |      | n        |
| `Keys`       |        |        |       | ‚úì    | n        |
| `Last`       | ‚úì      | ‚úì      | ‚úì     |      | 1        |
| `LastOr`     | ‚úì      | ‚úì      | ‚úì     |      | 1        |
| `Len`        | ‚úì      | ‚úì      | ‚úì     |      | 1        |
| `Max`        | ‚úì      | ‚úì      |       |      | n        |
| `Median`     |        | ‚úì      |       |      | n‚ãÖlog(n) |
| `Min`        | ‚úì      | ‚úì      |       |      | n        |
| `Reverse`    | ‚úì      | ‚úì      | ‚úì     |      | n        |
| `Select`     | ‚úì      | ‚úì      | ‚úì     |      | n        |
| `Sort`       | ‚úì      | ‚úì      |       |      | n‚ãÖlog(n) |
| `Sum`        |        | ‚úì      |       |      | n        |
| `Shuffle`    | ‚úì      | ‚úì      | ‚úì     |      | n        |
| `Top`        | ‚úì      | ‚úì      | ‚úì     |      | n        |
| `ToStrings`  | ‚úì      | ‚úì      | ‚úì     |      | n        |
| `Transform`  | ‚úì      | ‚úì      | ‚úì     |      | n        |
| `Unique`     | ‚úì      | ‚úì      |       |      | n‚ãÖlog(n) |
| `Unselect`   | ‚úì      | ‚úì      | ‚úì     |      | n        |
| `Values`     |        |        |       | ‚úì    | n        |

## func `All`(fn func(ElementType) bool) bool

All will return true if all callbacks return true. It follows the same logic as
the all() function in Python.

If the list is empty then true is always returned.

## func `Any`(fn func(ElementType) bool) bool

Any will return true if any callbacks return true. It follows the same logic as
the any() function in Python.

If the list is empty then false is always returned.

## func Append(elements ...ElementType) SliceType

Append will return a new slice with the elements appended to the end. It is a
wrapper for the internal append(). It is offered as a function so that it can
more easily chained.

It is acceptable to provide zero arguments.

## func AreSorted() bool

AreSorted will return true if the slice is already sorted. It is a wrapper for
`sort.SliceTypeAreSorted`.

## func AreUnique() bool

AreUnique will return true if the slice contains elements that are all different
(unique) from each other.

## func Average() float64

Average is the average of all of the elements, or zero if there are no elements.

## func Bottom(n int) SliceType

Bottom will return n elements from bottom.

That means that elements is taken from the end of the slice for this `[1,2,3]`
slice with n == 2 will be returned `[3,2]`

If the slice has less elements then n that'll return all elements. If n < 0
it'll return empty slice.

## func Contains(lookingFor ElementType) bool

Contains returns true if the element exists in the slice.

When using slices of pointers it will only compare by address, not value.

## func Each(fn func(ElementType)) SliceType

Each is more condensed version of `Transform` that allows an action to happen on
each elements and pass the original slice on.

```go
cars.Each(func (car *Car) {
	fmt.Printf("Car color is: %s\n", car.Color)
})
```

Pie will not ensure immutability on items passed in so they can be manipulated,
if you choose to do it this way, for example:

```go
// Set all car colors to Red.
cars.Each(func (car *Car) {
	car.Color = "Red"
})
```

## func Extend(slices ...SliceType) SliceType

Extend will return a new slice with the slices of elements appended to the end.

It is acceptable to provide zero arguments.

## func First() ElementType

First returns the first element, or zero. Also see FirstOr().

## func FirstOr(defaultValue ElementType) ElementType

FirstOr returns the first element or a default value if there are no elements.

## func Join(glue string) string

Join returns a string from joining each of the elements.

## func JSONString() string

JSONString returns the JSON encoded array as a string.

One important thing to note is that it will treat a nil slice as an empty slice
to ensure that the JSON value return is always an array.

## func Keys() KeySliceType

Keys returns the keys in the map. All of the items will be unique.

Due to Go's randomization of iterating maps the order is not deterministic.

## func Last() ElementType

Last returns the last element, or zero. Also see LastOr().

## func LastOr(defaultValue ElementType) ElementType

LastOr returns the last element or a default value if there are no elements.

## func Len() int

Len returns the number of elements.

## func Max() ElementType

Max is the maximum value, or zero.

## func Median() ElementType

Median returns the value separating the higher half from the lower half of a
data sample.

Zero is returned if there are no elements in the slice.

## func Min() ElementType

Min is the minimum value, or zero.

## func Reverse() SliceType

Reverse returns a new copy of the slice with the elements ordered in reverse.
This is useful when combined with Sort to get a descending sort order:

```go
ss.Sort().Reverse()
```

# FAQ

## What are the requirements?

`pie` supports many Go versions, all the way back to Go 1.8.

## What are the goals of `pie`?

1. **Type safety.** I never want to hit runtime bugs because I could pass in the
wrong type, or perform an invalid type case out the other end.

2. **Performance.** The functions need to be as fast as native Go
implementations otherwise there's no point in this library existing.

3. **Nil-safe.** All of the functions will happily accept nil and treat them as
empty slices. Apart from less possible panics, it makes it easier to chain.

4. **Immutable.** Functions never modify inputs, unlike some built-ins such as
`sort.Strings`.

## How do I contribute a function?

Pull requests are always welcome.

Here is a comprehensive list of steps to follow to add a new function:

1. Create a new file in the `functions/` directory. The file should be named the
same as the function. You must include documentation for your function.

2. Update `functions/main.go` to register the new function by adding an entry to
`Functions`. Make sure you choose the correct `For` value that is appropriate
for your function.

3. Run `go generate ./... && go install && go generate ./...`. The first
`generate` is to create the pie templates, `install` will update your binary for
the annotations and the second `generate` will use the newly created templates
to update the generated code for the internal types. If you encounter errors
with your code you can safely rerun the command above.

4. If you chose `ForAll` or `ForStructs`, then you must add unit tests to
`pie/carpointers_test.go` and `pie/cars_test.go`.

5. If you chose `ForAll`, `ForNumbersAndStrings` or `ForNumbers`, then you must
add unit tests to `pie/float64s_test.go` and `pie/ints_test.go`.

6. If you chose `ForAll` or `ForStrings`, then you must add unit tests to
`pie/strings_test.go`.

7. If you chose `ForMaps`, then you must add unit tests to `pie/currencies.go`.

8. Update the README to list the new functions.

## Why is the emoji a slice of pizza instead of a pie?

I wanted to pick a name for the project that was short and had an associated
emoji. I liked pie, but then I found out that the pie emoji is not fully
supported everywhere. I didn't want to change the name of the project to cake,
but pizza pie still made sense. I'm not sure if I will change it back to a pie
later.
